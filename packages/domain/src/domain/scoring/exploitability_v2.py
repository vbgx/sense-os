from __future__ import annotations

from dataclasses import dataclass

from domain.scoring.exploitability import (
    ExploitabilityInputs,
    ExploitabilityTier,
    ExploitabilityBreakdown,
    ExploitabilityResult,
    compute_exploitability,
)
from domain.scoring.underserved_v1 import compute_underserved_factor_v1


EXPLOITABILITY_VERSION_V2 = "exploitability_v2"


@dataclass(frozen=True)
class ExploitabilityV2Breakdown:
    exploitability_v1: int
    underserved_factor: int
    underserved_multiplier: float
    raw_v2: float


def _clamp100_int(x: int) -> int:
    if x < 0:
        return 0
    if x > 100:
        return 100
    return int(x)


def compute_exploitability_v2(
    inputs: ExploitabilityInputs,
    *,
    competitive_density_score: int,
    ph_overlap_score: int,
    repo_density_score: int,
    keyword_saturation_score: int,
) -> tuple[ExploitabilityResult, ExploitabilityV2Breakdown]:
    v1 = compute_exploitability(inputs)

    underserved = compute_underserved_factor_v1(
        competitive_density_score=competitive_density_score,
        ph_overlap_score=ph_overlap_score,
        repo_density_score=repo_density_score,
        keyword_saturation_score=keyword_saturation_score,
        competitive_heat_score=int(inputs.competitive_heat_score or 0),
    )

    underserved_norm = float(underserved.underserved_factor) / 100.0
    multiplier = 0.9 + 0.2 * underserved_norm

    raw_v2 = float(v1.exploitability_score) * multiplier
    score_v2 = _clamp100_int(int(round(raw_v2)))
    tier_v2 = v1.exploitability_tier
    if score_v2 >= 80:
        tier_v2 = ExploitabilityTier.STRONG_BUILD
    elif score_v2 >= 60:
        tier_v2 = ExploitabilityTier.INVESTIGATE
    elif score_v2 >= 40:
        tier_v2 = ExploitabilityTier.MONITOR
    else:
        tier_v2 = ExploitabilityTier.IGNORE

    v2 = ExploitabilityResult(
        exploitability_score=score_v2,
        exploitability_tier=tier_v2,
        exploitability_version=EXPLOITABILITY_VERSION_V2,
        breakdown=ExploitabilityBreakdown(
            half_life_normalized=v1.breakdown.half_life_normalized,
            pain_strength=v1.breakdown.pain_strength,
            timing_strength=v1.breakdown.timing_strength,
            risk_penalty=v1.breakdown.risk_penalty,
            raw_score=raw_v2,
        ),
    )

    return v2, ExploitabilityV2Breakdown(
        exploitability_v1=v1.exploitability_score,
        underserved_factor=underserved.underserved_factor,
        underserved_multiplier=multiplier,
        raw_v2=raw_v2,
    )
