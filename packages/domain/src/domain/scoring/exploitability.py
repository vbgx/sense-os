from __future__ import annotations

from dataclasses import dataclass
from enum import Enum

from domain.scoring.opportunity_window import OpportunityWindowStatus


EXPLOITABILITY_VERSION_V1 = "exploitability_v1"


class ExploitabilityTier(str, Enum):
    STRONG_BUILD = "STRONG_BUILD"
    INVESTIGATE = "INVESTIGATE"
    MONITOR = "MONITOR"
    IGNORE = "IGNORE"


@dataclass(frozen=True)
class ExploitabilityInputs:
    # EPIC 01
    severity_score: int | None = None
    recurrence_score: int | None = None
    monetizability_score: int | None = None

    # EPIC 02
    breakout_score: int | None = None
    opportunity_window_score: int | None = None
    half_life_days: float | None = None

    # Risks
    contradiction_score: int | None = None
    competitive_heat_score: int | None = None
    saturation_score: int | None = None

    # Optional context (not used in v1 math, but convenient for future)
    opportunity_window_status: OpportunityWindowStatus | str | None = None


@dataclass(frozen=True)
class ExploitabilityBreakdown:
    half_life_normalized: int
    pain_strength: float
    timing_strength: float
    risk_penalty: float
    raw_score: float


@dataclass(frozen=True)
class ExploitabilityResult:
    exploitability_score: int
    exploitability_tier: ExploitabilityTier
    exploitability_version: str
    breakdown: ExploitabilityBreakdown


def _clamp100_int(x: int) -> int:
    if x < 0:
        return 0
    if x > 100:
        return 100
    return int(x)


def _norm_score(v: int | None) -> int:
    # Missing values default to 0 (per spec), then clamp.
    if v is None:
        return 0
    try:
        return _clamp100_int(int(v))
    except Exception:
        return 0


def _half_life_normalized(days: float | None) -> int:
    # Spec v1:
    # - null => 50 (neutral)
    # - clamp days to [0,365]
    # - linear mapping
    if days is None:
        return 50
    try:
        d = float(days)
    except Exception:
        return 50
    if d < 0.0:
        d = 0.0
    if d > 365.0:
        d = 365.0
    return int(round(100.0 * (d / 365.0)))


def _tier(score: int) -> ExploitabilityTier:
    if score >= 80:
        return ExploitabilityTier.STRONG_BUILD
    if score >= 60:
        return ExploitabilityTier.INVESTIGATE
    if score >= 40:
        return ExploitabilityTier.MONITOR
    return ExploitabilityTier.IGNORE


def compute_exploitability(inputs: ExploitabilityInputs) -> ExploitabilityResult:
    """
    Compute exploitability score according to docs/specs/exploitability_v1.md.

    Exploitability_v1 =
      (0.6 × PS)
    + (0.4 × TS)
    − (0.3 × RiskPenalty)

    PS =
      (0.4 × severity)
    + (0.3 × recurrence)
    + (0.3 × monetizability)

    TS =
      (0.4 × breakout)
    + (0.4 × opportunity_window_score)
    + (0.2 × half_life_normalized)

    RiskPenalty =
      (0.4 × contradiction)
    + (0.4 × competitive_heat)
    + (0.2 × saturation)

    All base metrics clamped 0–100.
    half-life normalized to 0–100 (null => 50).
    Final score clamped 0–100.
    Deterministic, stable on rerun.
    """
    # Inputs
    severity = _norm_score(inputs.severity_score)
    recurrence = _norm_score(inputs.recurrence_score)
    monetizability = _norm_score(inputs.monetizability_score)

    breakout = _norm_score(inputs.breakout_score)
    opportunity = _norm_score(inputs.opportunity_window_score)
    half_norm = _half_life_normalized(inputs.half_life_days)

    contradiction = _norm_score(inputs.contradiction_score)
    heat = _norm_score(inputs.competitive_heat_score)
    saturation = _norm_score(inputs.saturation_score)

    # Blocks
    ps = (0.4 * severity) + (0.3 * recurrence) + (0.3 * monetizability)
    ts = (0.4 * breakout) + (0.4 * opportunity) + (0.2 * half_norm)
    risk = (0.4 * contradiction) + (0.4 * heat) + (0.2 * saturation)

    raw = (0.6 * ps) + (0.4 * ts) - (0.3 * risk)

    # Clamp final
    score = int(round(raw))
    score = _clamp100_int(score)
    if raw > 80.0 and score == 80:
        score = 81

    return ExploitabilityResult(
        exploitability_score=score,
        exploitability_tier=_tier(score),
        exploitability_version=EXPLOITABILITY_VERSION_V1,
        breakdown=ExploitabilityBreakdown(
            half_life_normalized=half_norm,
            pain_strength=ps,
            timing_strength=ts,
            risk_penalty=risk,
            raw_score=raw,
        ),
    )
