# Exploitability v1 — Spec (0–100)

Status: OFFICIAL v1 (ready for implementation)  
Version name: `exploitability_v1`

## Purpose

Exploitability answers one question:

**“Is it worth investing time now?”**

It is not:
- scientific truth
- clustering quality

It is:
- rational action potential based on current evidence

Exploitability is:
- deterministic
- bounded (0–100)
- explainable (breakdown by block + components)
- versioned

---

## Inputs (0–100 unless noted)

From EPIC 01 — Pain Intelligence V2:
- `severity_score` (0–100)
- `recurrence_score` (0–100)
- `monetizability_score` (0–100)

From EPIC 02 — Trend Engine Pro:
- `breakout_score` (0–100)
- `opportunity_window_score` (0–100)
- `half_life_days` (float | null)

Risk proxies:
- `contradiction_score` (0–100)
- `competitive_heat_score` (0–100)
- `saturation_score` (0–100)

---

## Normalization Rules

### Base metric normalization (0–100)

All score inputs are treated as:
- integers 0–100
- clamped before use

Rule:
- if value < 0 => 0
- if value > 100 => 100

### Half-life normalization (days → 0–100)

Half-life is optional and normalized into `half_life_normalized` (0–100).

Let:
- `d = half_life_days`

If `d` is null:
- `half_life_normalized = 50` (neutral default)

Else:
- clamp `d` to [0, 365] (beyond 1 year treated as max durability for v1)
- normalize linearly:

`half_life_normalized = round(100 * (clamp(d,0,365) / 365))`

Rationale:
- v1 keeps a simple, stable mapping
- no nonlinear “magic” until data justifies it

---

## v1 Weight Table

### 1) Pain Strength (PS)

PS combines pain intensity + recurrence + monetizability.

PS =
- 0.4 × severity_score
- 0.3 × recurrence_score
- 0.3 × monetizability_score

Weights sum = 1.0

### 2) Timing Strength (TS)

TS combines breakout + opportunity + durability.

TS =
- 0.4 × breakout_score
- 0.4 × opportunity_window_score
- 0.2 × half_life_normalized

Weights sum = 1.0

### 3) Risk Adjustment (Risk Penalty)

Risk Penalty combines contradiction + competition + saturation.

Risk Penalty =
- 0.4 × contradiction_score
- 0.4 × competitive_heat_score
- 0.2 × saturation_score

Weights sum = 1.0

---

## Final Score

Exploitability_v1 =
- (0.6 × PS)
- + (0.4 × TS)
- − (0.3 × Risk Penalty)

Then clamp to [0, 100].

Clamp rule:
- if < 0 => 0
- if > 100 => 100

---

## Null / Missing Handling

- Any missing score input defaults to 0 **except** half-life.
- `half_life_days = null` => `half_life_normalized = 50` (neutral)
- All defaults are applied **before** block computation.

Reason:
- scoring must be stable and computable for all clusters
- half-life missing is “unknown durability”, not “zero durability”

---

## Output Fields (v1 spec)

- `exploitability_score` (0–100)
- `exploitability_tier` (enum)
- `exploitability_version` = `"exploitability_v1"`

Tier mapping:
- 80–100: `STRONG_BUILD`
- 60–79: `INVESTIGATE`
- 40–59: `MONITOR`
- 0–39: `IGNORE`

---

## Worked Example (numeric)

Given:

severity_score = 80  
recurrence_score = 70  
monetizability_score = 60  

breakout_score = 75  
opportunity_window_score = 65  
half_life_days = 120  

contradiction_score = 20  
competitive_heat_score = 50  
saturation_score = 30

Step A — half-life normalization:

half_life_normalized = round(100 * (120 / 365))
= round(32.88)
= 33

Step B — Pain Strength (PS):

PS =
(0.4*80) + (0.3*70) + (0.3*60)
= 32 + 21 + 18
= 71

Step C — Timing Strength (TS):

TS =
(0.4*75) + (0.4*65) + (0.2*33)
= 30 + 26 + 6.6
= 62.6

Step D — Risk Penalty:

Risk =
(0.4*20) + (0.4*50) + (0.2*30)
= 8 + 20 + 6
= 34

Step E — Final exploitability:

Exploitability =
(0.6*71) + (0.4*62.6) − (0.3*34)

= 42.6 + 25.04 − 10.2
= 57.44

Final (clamp + round):
exploitability_score = 57

Tier:
57 => MONITOR

---

## Edge Cases

### 1) All zeros
All inputs 0, half-life null (=> 50):

PS = 0  
TS = (0.4*0 + 0.4*0 + 0.2*50) = 10  
Risk = 0  
Final = (0.6*0) + (0.4*10) − (0.3*0) = 4

=> exploitability_score = 4 (IGNORE)

### 2) Extreme high pain + perfect timing but high risk
If Risk Penalty is high, final score must drop accordingly.
This is intended: actionability is reduced under contradiction/competition/saturation.

### 3) Missing half-life
half_life_days = null => half_life_normalized = 50 (neutral), does not kill the score.

### 4) Out-of-range inputs
Inputs are clamped to 0–100 before any computation. No overflow.

---

## Implementation Notes (for Issue 03.02+)

Required breakdown for explainability:
- PS, TS, Risk Penalty
- half_life_normalized
- final raw value before clamp (optional, for debugging)

Versioning:
- All implementations must attach `exploitability_version = "exploitability_v1"`
- Future versions must not change v1 behavior.
